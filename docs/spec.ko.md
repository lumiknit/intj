# INTJ 명세 Version 0

## -1. 서론

### 스택 표기법

이 언어는 스택 지향적이기 때문에 문서에서 스택 상태를 표시하는 것이 중요합니다.

- `[]` 는 빈 스택을 나타냅니다.
- `[1, 2, 3]` 은 스택에 `1, 2, 3` 이 포함된 상태를 나타내며, 스택의 맨 위에 있는 요소는 가장 왼쪽에 위치합니다.
- 줄임표(...)는 일부 요소를 나타냅니다. 예를 들어, `[1, 2, ..., 5, ...]` 와 같이 사용합니다.

---

## 0. INTJ 란 무엇인가요?

**Intelligent JSON (INTJ)**는 JSON을 그대로 받아들일 수 있는 간단한 언어입니다.

### 목적

- INTJ는 JSON, 정규 표현식, HTTP Fetch 등과 같은 일반적인 프로그래밍을 위한 경량의 효율적인 언어로 설계되었습니다.
  - 인간 친화성보다는 컴퓨터 친화성을 우선시합니다.
- INTJ는 기본적으로 JSON을 데이터 형식으로 지원합니다.
- Rust로 구현해 작은 바이너리를 제공합니다.
- INTJ는 JavaScript나 WebAssembly (wasm)를 사용하여 웹에서 실행할 수 있습니다.

### 특징

- INTJ는 스택 지향 언어입니다.
  - 메인 스택은 임시 값, 인수 및 결과를 저장하는 데 사용됩니다.
  - 스택은 모든 함수와 연산에서 공유됩니다.
  - 대부분의 단어들은 값을 스택에 넣거나 꺼내는 방식으로 스택을 조작합니다.

- INTJ는 동적 타입 언어입니다.
  - 스택의 각 셀에는 어떤 유형의 데이터도 포함될 수 있습니다.

- INTJ는 JSON 를 그대로 받아들입니다.
  - INTJ의 문법은 JSON 및 JSON5를 온전히 포함합니다.
  - JSON 코드를 INTJ에 그대로 복사해 붙여넣어도 문제가 없으며, 그 경우에 JSON 객체를 스택에 넣게 됩니다.
  - 단, 각 기호의 의미는 JSON과 다를 수 있습니다.

- 함수는 1급 객체입니다.
  - 함수는 값으로 취급되어 스택에 푸시될 수 있습니다.
  - 함수는 기본적으로 명령어 목록입니다.

- 모든 명명(binding)은 불변입니다.
  - INTJ는 명명된 값을 변경하는 것을 허용하지 않으므로 프로그램의 예측 가능성을 높이고 디버깅을 단순화합니다.

---

## 1. 언어의 기본 요소

### 주석

INTJ의 주석은 C/C++/Java/JavaScript와 유사합니다.

```intj
// 이것은 한 줄 주석입니다
/* 이것은 블록 주석입니다 */
/// 이것은 문서 주석입니다.
```

추가적으로, 다른 스크립트 언어처럼 INTJ는 셰뱅(shebang)을 사용할 수 있습니다.

```intj
#!/usr/bin/env intj
```

### 평가 순서

INTJ에서 코드는 위에서 아래로, **오른쪽에서 왼쪽으로** 실행됩니다. 예를 들어:

```intj
1 2 3
4 5 6
```

위 코드에서 첫 번째 줄(`1 2 3`)이 먼저 실행되고, 그 다음으로 두 번째 줄(`4 5 6`)이 실행됩니다. 각 줄에서는 가장 오른쪽에 있는 요소가 먼저 실행됩니다. 따라서 실행 순서는 `3 2 1 6 5 4`가 됩니다.

이 실행 순서는 일부 사람들에게는 직관적이지 않겠지만, 다른 일반적인 프로그래밍 언어와 유사하게 보이도록 설계되었습니다.

조금 더 설명하자면, 대부분의 스택 지향 언어에서 함수는 인수가 스택에 푸시된 후 호출됩니다. 예를 들어, Forth에서 두 숫자를 더하고 'print' 함수를 호출하는 코드는 다음과 같습니다:

```forth
1 2 + print
```

이 구문은 다른 언어들, 예를 들어:

```javascript
print(1 + 2)
```

와 비교했을 때 다소 생소하게 보일 수 있습니다.

INTJ는 Forth 와 달리 인수의 순서를 반대로 하여, 다른 프로그래밍 언어들과 더 유사하게 보이도록 설계되었습니다:

```intj
print + 1 2
```

이와 같은 문법은 [Uiua](https://uiua.org)에 크게 영향을 받았습니다.

### 줄 구분자

개행 문자는 평가 순서를 변경하는 데 사용할 수 있는 특별한 기호입니다.
하지만 개행을 추가하지 않고 실행 순서를 변경하고 싶을 수도 있죠.
그런 경우에는 쉼표(,)를 줄 구분자로 사용할 수 있습니다.

예를 들어, 다음과 같이 작성하는 대신:

```intj
1 2 3
4 5 6
```

다음과 같이 쓸 수 있습니다:

```intj
1 2 3, 4 5 6
```

두 코드는 동일하게 동작하지만, 아래에서는 개행이 없습니다.

여러 개의 개행과 쉼표를 섞어서 사용할 수도 있습니다. 예를 들어:

```intj
1 2,,,3,4 5 6,,

7
```

위 코드는 다음과 동일합니다:

```intj
1 2, 3, 4 5 6, 7
```

여기서 몇 가지 중요한 점을 염두에 두어야 합니다:

- 한 줄 주석은 개행을 포함하지 않습니다. 즉, 한 줄 주석 뒤에도 개행이 있으므로 줄 구분자로도 취급됩니다.
- 블록 주석이 여러 줄에 걸쳐 있을 경우, 파서는 주석 내의 개행은 무시합니다. 예를 들어:

  ```intj
  a b c   /* 몇 가지 긴 주석
  여기 끝남 */ d e f
  ```

  은 다음:

  ```intj
  a b c d e f
  ```

  처럼 개행이 포함되어 있지만, 주석을 지우고 본 것과 동일하게 처리됩니다.

- 마찬가지로, 괄호, 객체, 배열 안에 있는 코드 블록이 새 줄을 포함할 경우, 파서는 이를 단일 줄로 취급합니다.

  예를 들어:

  ```intj
  a b (
    c
  ) d
  ```

  는 `a b (c) d` 와 동일하되, `a b (c), d` 와는 다릅니다.

### 리터럴

INTJ에서는 JSON 에서 제공되는 모든 리터럴에 더해 추가적인 형식도 지원합니다.

- 특수 값: `null`, `true`, `false`
  - 이 값들은 예약어가 아니라 표준 라이브러리의 일부입니다. `std.null`, `std.true`, `std.false` 로 사용할 수 있습니다.

- 숫자
  - INTJ는 JSON과 동일한 숫자 형식을 지원합니다. 예를 들어 `-12.345e-6` 등이 있습니다.
  - 추가로, INTJ는 16진수와 8진수 숫자를 허용합니다. 예를 들어 `0x1234`, `0o7624` 등이 있습니다.

- 문자열
  - INTJ는 JSON과 동일한 문자열 형식을 지원합니다. 예를 들어 `"Hello, world!\n"` 등이 있습니다.
  - 또한, INTJ는 문자열에서 단일 인용부호와 C 스타일의 이스케이프 시퀀스를 사용할 수 있습니다. 예를 들어 `'single quote\a\f\uAFFF'` 등이 있습니다.

INTJ 코드에서 모든 리터럴은 해당 값을 스택에 넣는 명령으로 볼 수 있습니다.

예를 들자면,

```intj
42        // 숫자 42를 스택에 푸시합니다
"Hello!"  // 문자열 "Hello, world!"를 스택에 푸시합니다
```

### 심볼

심볼은 문자열처럼 생긴 특별한 유형의 리터럴입니다. 심볼을 정의하는 가장 쉬운 방법은 문자열 뒤에 콜론(:)을 사용하는 것입니다.

```intj
"hello":   // => 심볼 'hello'
'world':   // => 심볼 'world'
"good"  :  // => 문자열과 콜론 사이의 공백도 허용됩니다.

"good!"
  :       // 개행을 넣어도 되지만, 권장하지 않습니다.
```

내부적으로 심볼은 일종의 정수에 불과하며, 같은 이름이면 같은 정수 값이라는 것만 보장합니다. 심볼은 키와 같은 짧은 문자열을 비교할 때 유용할 수 있습니다.

식별자 형태로 심볼로 사용할 때도 콜론(:)을 추가하면 됩니다.

```intj
my-good-value:  // => 심볼 'my-good-value'
wow!ItWorks:    // => 심볼 'wow!ItWorks'
```

심볼을 정수로 변환하거나 그 반대로 변환하려면 표준 함수를 사용할 수 있습니다.

### 배열과 객체

배열과 객체를 생성하려면 `[]`와 `{}`를 사용하세요. JSON과 동일하게 사용할 수 있습니다. 예를 들어:

```intj
[1, 3, 5] // => [1, 3, 5]
{"a": 1, "b": 2} // => {a: 1, b: 2}
```
중요한 점으로, 위에서 유일한 특별한 구문은 괄호 뿐이라는 것입니다. 쉼표, 콜론 및 기타 문자들은 위에서 설명한 INTJ 의 구문들과 동일합니다. 예를 들어, 위 코드에서 각 리터럴은 단순히 해당 값을 스택에 넣으며, 쉼표는 단순한 줄 구분자일 뿐입니다. 비슷하게 다음과 같은 코드도 유효합니다:

```intj
[1
 3
 {,
  header: "test",,, body: "test"
 }]
```

이 코드는 `[1, 3, {header: "test", body: "test"}]` 와 동일합니다.

INTJ의 유연성 덕분에 JSON5 구문도 허용됩니다.

이것이 어떻게 작동하는지 함수에 대해 설명한 후 설명하겠습니다.

### 식별자

예약된 문자를 포함하지 않는 대부분의 단어 중 리터럴로 해석되지 않는다면 모두 유효한 식별자입니다. 유니코드 문자도 허용됩니다.

예약된 문자는 다음과 같습니다:

- 공백 문자 (공백, 탭, 줄바꿈 등 ASCII의 U+0000부터 U+0020까지)
- 구분자 문자 `,`
- 심볼 문자 `:`
- 괄호 `()[]{}`
- 해쉬 `#`
- 따옴표 `'`, `"`, ``` ` ```

추가적으로, 몇몇 특수 문자는 '연산자 문자'로 간주됩니다.

- `+`, `-`, `*`, `/`, `%`, `&`, `|`, `^`, `~`, `!`, `=`, `<`, `>`, `?`, `@`, `$`, `;`

이 문자도 역시 식별자로 사용할 수 있지만, `=` 문자는 조금 특별하게 처리됩니다. 이는 나중에 설명하겠습니다.

추가적으로, INTJ 에서는 식별자의 대소문자를 구분하지 않습니다. 문자열과 심볼은 대소문자를 구분한다는 점을 주의하세요.

예를 들어, 다음은 유효한 식별자입니다:

```intj
hello
WOrLd        // 'world'와 동일합니다.
hello_world
good+morning // 이건 하나의 식별자입니다!
3<->4        // 이것도 하나의 식별자구요.
안녕!        // 유니코드가 들어가도 괜찮습니다.
```

특수 문자를 식별자에 사용하려면, 식별자를 백틱(``` ` ```)으로 묶으면 됩니다. 백틱은 줄 바꿈과 백틱 자체를 제외한 대부분의 문자를 허용합니다. 문자열 리터럴과 달리, 백틱 안에서는 이스케이프 시퀀스를 사용할 수 없습니다.

```intj
`hello, world!` // => 식별자 'hello, world!'
`안녕!`         // => 식별자 '안녕!'
```

리터럴은 단순히 값을 스택에 넣지만, 식별자의 동작은 해당 식별자로 명명된 값에 따라 다릅니다.

- 함수를 해당 식별자로 명명한 경우, 함수가 호출됩니다.
- 함수가 아닌 값을 해당 식별자로 명명한 경우, 해당 값을 스택에 넣습니다.

예를 들어:

```intj
a = 42
b = [3, 2, 1]
f = (print "Hello")  // 함수는 이렇게 정의합니다. 나중에 자세히 설명할게요.

a  // 그냥 42를 스택에 넣습니다.
b  // 비슷한 경우죠.
f  // 함수니까 호출하게 되고, "Hello" 가 스택에 들어갑니다.
```

### 명명 (Binding)

`=` 연산자를 사용하여 값을 식별자로 명명할 수 있습니다.

```intj
my_val = 42 // 42를 'my_val'에 바인딩합니다.
a= 3        // 식별자 뒤의 공백은 생략할 수 있지만, 권장하지 않습니다.

// 잘못된 경우:
// x
// = 42  // 개행 문자는 사용할 수 없어요.
// y /* comment */ = boom
```

정확히 말하자면, `<ID> =` 형식은 스택에서 값을 하나 꺼내서 식별자로 명명하는 명령입니다. 다르게 말하자면 우변은 필수적이지 않습니다.

```intj
"hello" 42  // 스택은 ["hello", 42, ...]이 됩니다.
a= b=       // 먼저, "hello"가 꺼내져 b 로 명명됩니다. 이후 42가 꺼내져 a로 명명되죠. 결과적으로 a=42, b="hello"가 됩니다.
```

명명 구문 형식 때문에, `<=`, `>=` 같은 일부 연산자 역시 명명 구문처럼 보일 수 있습니다. 매번 백틱을 사용하여 접미사가 `=`인 연산자를 작성하는 것은 너무 번거롭기 때문에, INTJ는 두 개 이상의 연산자 문자가 끝에 있는 식별자는 바인딩이 아닌 것으로 간주합니다.

```intj
a=           // 명명입니다.
a<=          // '<='는 두 문자로 된 연산자이므로, 식별자 `a<=`입니다.
**=          // 이것도 식별자입니다.
good<-to=    // 마지막 연산자 문자가 '='이기 때문에, 이 경우는 명명입니다.
```

### 함수

INTJ에서 함수는 그저 코드의 그룹에 불과합니다. 함수는 `()`를 사용하여 정의할 수 있습니다.

```intj
pop_and_double = (* 2 pop)
swap = (
  a= b=   // 첫 번째 줄이 먼저 실행되어, 값을 b와 a로 명명합니다.
  a b     // 그런 다음 b와 a를 다시 넣죠.
)

3 4 5 // => [3, 4, 5, ...]
swap  // => [4, 3, 5, ...]
pop_and_double // => [6, 5, ...]
```

명명된 단어를 사용하면 함수를 바로 호출하기 때문에, 호출하지 않고 함수를 스택에 넣으려면 `()`로 감싸야 합니다. 컴파일러가 최적화하기 때문에 성능에 대해 걱정할 필요는 없습니다.

```intj
t = pop_and_double   // 이렇게 하면 함수가 바로 호출됩니다.
t = (pop_and_double) // 하지만 이렇게 하면 호출 없이 넣습니다.
t = (42)  // t = 42 와 거의 동일하지만, 42를 넣는 함수로 취급됩니다.
```

함수 관련 참고사항:

- 다른 일반적인 언어와 달리, INTJ는 명시적인 함수 매개변수가 없습니다. 대신, 명명 구문을 사용하여 인수를 가져옵니다:

  ```intj
  f = (
  arg1 =, arg2 =, arg3 =
  // Your code here
  )
  ```

- 다른 일반적인 언어와 달리, INTJ는 모든 함수에 대해 명시적인 반환문을 제공하지 않습니다. 대신, 표준 라이브러리에서 사용자는 'break'를 만들어 함수를 종료할 수 있습니다.

### 배열과 객체의 작동 원리

이제 INTJ에서 배열과 객체가 어떻게 작동하는지 설명하겠습니다.

INTJ에서 배열과 객체에 사용되는 괄호는 단순히 문법적인 설탕입니다. 이는 함수와 일부 표준 명령으로 대체할 수 있습니다:

```intj
std.array (1, 2, 3) // [1, 2, 3]와 동일합니다.
```

보시다시피, 위 코드는 `[3, 2, 1]` 값을 푸시하는 함수를 푸시하고, 그런 다음 `std.array` 함수를 호출할 뿐입니다.

신기한 동작은 `std.array` 함수 내에서 일어납니다. 이 함수는 여러 값을 넣는 함수를 받아 그 함수가 넣어둔 값으로 배열을 생성합니다.

`std.array` 함수는 다음과 같이 구현할 수 있습니다 (아주 정확한건 아닙니다):

```intj
array = (
  push_values = // 우선 인수에 이름을 붙이죠.

  // 스택에 시작 마커를 입력합니다.
  // std.mark 는 고유한 값을 가진 마커를 넣습니다.
  std.mark

  // 마커를 복사해서 저장해둡니다.
  mark = dup

  // 값을 전부 집어넣구요.
  push_values

  arr = std.empty_array

  // 이제 시작 마커까지의 값을 모두 배열에 넣습니다.
  std.until mark (v =
    std.push_array_front v arr
  )

  arr
)
```

실제 코드는 런타임에 의해 최적화가 되겠지만, 내부적인 동작은 위와 거의 비슷합니다. 다시 말해 `array` 함수는 단순히 값을 역순으로 배열에 넣는 것이죠.

이것을 활용한다면, 여러분은 배열을 만들 때 산술 연산이나 문자열 조작 등을 포함해볼 수 있습니다.

```intj
[
  + 32 10 // 이 코드는 결과적으론 42 하나를 넣습니다.
  trim "  hello world " // 마찬가지로 "hello world"를 넣습니다.
]
```


객체의 경우도 비슷하게 작동합니다. 함수가 키-값 쌍을 올바르게 넣는다면, `object` 함수가 이를 객체로 묶어줍니다. 예를 들어:


```intj
{
  "number": 42,
  value: 5
}
```

위는 다음과 같이 작동합니다:

- 먼저, 스택에 시작 마커를 추가합니다.
- 함수를 평가합니다.
  - 스택은 `[value:, 5, number:, 42, MARKER, ...]`가 됩니다.
- 마지막으로, 마커까지 2개의 값을 꺼내 객체로 변환합니다.
  - 첫 번째 키-값 쌍은 `value:`와 `5`입니다.
  - 두 번째 키-값 쌍은 `number:`와 `42`입니다.

스택 조작에 익숙해진다면, 더 복잡하지만 실용적이지 않은 방법으로 배열과 객체를 구성할 수도 있습니다. 예를 들어, `swap`을 사용하여 두 값을 반전시킬 수 있습니다:

```intj
[ 1, 2, swap ] // => [2, 1]
{
  [ key1:, key2:, my-val: ]
  [ 42, true, null ]
  push_zip // 두 배열을 서로 교차하며 값을 넣습니다.
} // => {key1: 42, key2: true, my-val: null}
```

---

## 2. 명명 (Binding), 명명 구역 (Scope) 및 모듈

이전에 언급한 대로, INTJ에서 값들을 저장하거나 가져오기 위해서는 아래 두 개념을 사용할 수 있습니다.

1. 스택: 스택은 임시 값, 인수 및 결과를 저장하는 전역 공유 데이터 구조입니다. 전체 프로그램에서 접근할 수 있어보이죠.

2. 명명: 명명된 값은 함수 또는 모듈의 범위 내에 저장됩니다. 각 함수 또는 모듈은 자체 명단을 가지며 해당 범위 내에서 액세스할 수 있습니다.

명명 범위 및 모듈 시스템에 대해 자세히 알아보겠습니다.

### 스코프와 스택

INTJ 런타임에서는 단일 스택뿐만 아니라 여러 종류의 스택이 있습니다.

- **값 스택**: 이전에 설명한 스택입니다. 단일 실행 루틴에 사용됩니다.

- **프레임 스택**: 호출 스택의 일종입니다. 함수를 호출할 때마다 새로운 프레임이 생성되어 프레임 스택에 푸시됩니다. 함수에서 나올 때 프레임을 꺼내게 됩니다.

값 스택에 없는 값, 예를 들어 명명된 값 및 명령 포인터 (instruction pointer)와 같은 일부 특수 값은 프레임 스택의 각 프레임에 저장됩니다. 다시 말해, `a = 42`와 같이 값에 명명할 때, 런타임은 현재(즉, 맨 위) 프레임의 `a`라는 셀에 `42`를 저장합니다.

그럼 "전역 또는 최상위에서 명명된 값은 어느 프레임에 저장되나요?" 같은 의문이 드실 것입니다.

```intj
f = (
  a = 42 // 이건 당연히 f 의 프레임에 저장되겠죠.
)
g = "boom" // 이건 도대체 어디에 저장되는 걸까요?
```

### 모듈 명명 구역

INTJ에서 전역 또는 최상위에 명명된 값은 모듈의 프레임에 저장됩니다. 각 모듈은 자체적으로 프레임을 가지며, 모듈의 최상위에서 명며된 값이 포함됩니다. 모듈을 가져올 (import) 때 모듈의 프레임이 생성되고, 모듈 생성 함수에서 각종 값을 명명하게 됩니다. 이렇게 명명된 값은 모듈의 범위 내에서 접근 가능하며, 모듈을 가져온 다른 함수나 모듈에서도 사용할 수 있습니다.

예를 들어, 다음 INTJ 를 생각해보죠:

```intj
a = 42
str = "Hello, world!"
```

이 경우, `a`와 `str`은 모듈의 프레임 내에서 명명됩니다. 누군가 이 모듈을 가져온다면, 모듈의 프레임이 생성되고 바인딩 `a`와 `str`이 프레임에 추가됩니다. 이 모듈을 가져오는 다른 함수나 모듈은 자체 프레임 내에서 명명된 값을 사용할 수 있습니다.

모듈의 프레임은 해당 모듈에 특정한 전역 또는 최상위 바인딩을 포함하는 일종의 명명 구역으로 생각할 수 있습니다. 모듈에서 명명된 값은 모듈 내 코드 전체에서 접근하고 사용할 수 있습니다.

### 모듈 가져오기

모듈을 가져오려면 `#` 다음에 괄호를 사용하면 됩니다. 괄호 안에 가져올 모듈을 나열하면 되고, 필요에 따라서는 별칭을 지정할 수 있습니다.

```intj
#(
  "my_module.intj" // 'my_module.intj'를 가져와 'my_module'에 바인딩합니다
  mod2 = "my_module2.intj" // 'my_module2.intj'를 가져와 'mod2'에 바인딩합니다
  "also" // 파일 확장자 '.intj'를 생략할 수 있습니다
  sub = "subdir/sub_module.intj" // 'subdir/sub_module.intj'를 가져와 'sub'에 바인딩합니다
  sub = "subdir/file2.intj" // 모듈을 다시 가져와서 덮어쓸 수 있습니다
  full_dir = "my_dir/" // 'my_dir/'에 있는 모든 .intj 파일을 가져옵니다
  _ = "my_dir/overwirte.intj" // 접두사를 할당하지 않고 모듈을 가져올 수 있습니다
)
```

모듈을 가져온 후에는 접두사를 사용하여 해당 모듈에 명명된 값에 접근할 수 있습니다. 기본적으로 접두사는 파일 이름 뒤에 점(`.`)을 붙인 것입니다. 가져올 때 괄호 안에 이름을 지정하면 해당 이름을 접두사로 사용할 수 있습니다.

예를 들어, 위의 가져오기 예시에서는:

```intj
my_module.a // my_module.intj에서 'a' 바인딩에 접근합니다.
mod2.b // my_module2.intj에서 'b' 바인딩에 접근합니다.
sub.print // 'subdir/sub_module.intj' 또는 'subdir/file2.intj'에서 'print' 바인딩에 접근합니다.
full_dir.some_fn // my_dir/에 있는 모든 .intj 파일에서 'some_fn' 바인딩에 접근합니다.
```

모듈 이름에 모호성이 있을 수 있다는 점은 주의해야 합니다. `.intj`의 모듈 체계는 엄격하지 않기에 모듈 이름을 사용할 때 주의해야 합니다.

모듈 가져오기는 코드 어디에서나 사용할 수 있습니다. 최상위가 아닌 경우에는 해당 함수 구역 내에서만 사용할 수 있습니다.

표준 라이브러리도 모듈이며, 경로는 빈 문자열(`""`)입니다. 기본적으로 모든 코드에서 다음과 같이 표준 라이브러리가 임포트됩니다:

```intj
#(
  std = ""
  _ = ""
)
```

즉, 표준 라이브러리는 `std.` 접두사를 사용하거나, 접두사 없이 사용할 수 있습니다.

### 모듈은 한 번만 로드됩니다

동일한 모듈을 여러 번 가져올 때, 모듈 코드는 한 번만 실행되고 동일한 모듈 인스턴스가 재사용됩니다.

대부분의 경우, 가져온 모듈은 가져오는 모듈보다 먼저 실행됩니다. 모듈 코드는 가져오기 문 `#(...)`에서 정확히 실행됩니다.

### 순환 모듈 가져오기와 불러와지지 않은 모듈

개인적인 의견이지만, 모듈에서 가장 빈번한 문제를 꼽자면 순환 가져오기와 그로 인해 완전히 불러오지 못한 모듈입니다.

예를 들어, 다음 코드를 생각해보죠:

```intj
// A.intj
#( "B" )
f = B.f
g = ( B.g 42 )

// B.intj
#( "A" )
f = A.f
g = ( A.g 42 )
```

위 코드를 `intj run A.intj`로 실행한다고 가정해봅시다. 이 경우, 모듈 `A`가 로드되기 시작하면서 모듈 `B`를 가져오게 됩니다. 그러나 모듈 `B`도 모듈 `A`를 가져오고 싶어 하죠. 앞에서 언급했듯이, 각 모듈은 한 번만 실행되어야 합니다.

이러한 상황을 올바르게 처리하기 위해 INTJ는 모듈을 가져오기 시작할 때 해당 모듈을 '아직 불러오지 않음' 상태로 표시합니다. 그리고 모듈 코드가 완전히 실행되면 '불러옴' 상태로 표시합니다. 모듈이 '아직 불러오지 않음' 상태에서 다시 가져온다면, 그 가져오기는 무시하게 됩니다.

예시에서 모듈 `B`가 모듈 `A`를 가져오려고 할 때, 모듈 `A`는 '아직 불러오지 않음' 상태이므로 가져오기는 무시됩니다. '아직 불러오지 않음' 상태의 모듈에서 바인딩에 접근하려고 하면 런타임에서 패닉이 발생합니다. 예를 들어, 주어진 예시에서 모듈 `B`가 `A.f`에 접근하려고 하면 패닉이 발생합니다.

순환 가져오기를 방지하기 위해 INTJ는 '아직 불러오지 않음' 상태라서 제대로 명명되지 않은 값에는 접근하지 못하게 막습니다. 다만 특정 경우에는 허용되는데요, 가져오기 과정 중에 호출되지 않는 함수 내에서 '아직 불러오지 않음' 상태의 모듈에서 바인딩에서 명명될 값에는 접근해도 문제 없습니다.ㄴ

예시에서 `B.g`는 `(A.g 42)`로 정의되고, 함수 내에서 `A.g`에 접근합니다. `A.g`는 가져오기 과정 중에는 호출되지 않으므로 런타임에서는 이 경우 패닉이 발생하지 않습니다.

### 지역 명명 구역과 클로저

함수 내에서 명명된 값은 해당 함수의 프레임에 저장됩니다. 그런데 함수 내에서는 해당 함수 내에서 명명된 값뿐만 아니라 외부에서 명명된 값도 사용할 수 있습니다. 이는 함수 내에서 함수를 생성할 때 내부 함수가 필요한 값들을 낚아채오기 (capture) 때문입니다.

예를 들어:

```intj
f = (
  a = 42
  b = true
  g = (
    + a 3 // g는 a를 사용하므로 a가 캡처되어야 합니다.
  )
  g // 이 g는 a의 캡처된 값을 가진 함수입니다.
)
```

이 방식은 굉장히 자연스럽고 당연해보입니다. 전역 또는 모듈에서 명명된 모든 값이 함수 내에서 사용 가능하고 이를 함수가 낚아채온 것이라고 생각할 수 있기 때문이죠. (참고: 최적화로 인해 실제 동작은 약간 다를 수 있습니다.)

### 문서 주석

값을 명명하기 직전에 `///`를 사용하여 문서 주석을 추가할 수 있습니다. 이 주석은 다양한 도구뿐만 아니라 런타임에서도 접근할 수 있습니다. 예를 들어, `help` 함수를 사용하여 특정 바인딩의 문서를 표시할 수 있습니다:

```intj
help "f" // f 의 문서를 표시합니다.
help ["a", "b", "c"] // a 함수 내에서 명명된 b 함수 내에서 명명된 c 바인딩의 문서를 표시합니다.
```

이 기능은 `std`의 reflect 및 runtime 기능을 사용하여 구현됩니다.

한가지 주의할 점은 문서 주석은 다음 줄의 가장 마지막으로 명명된 값에만 추가된다는 것입니다. 예를 들어:

```intj
/// Hello!
1 2 3 a= b= 42 "boom"
```

와 같은 경우에는 마지막에 명명되는 `a` 에만 문서 주석이 추가됩니다. `b` 에는 문서 주석이 추가되지 않습니다.

---

## 3. 자료형

### 기본 자료형

INTJ에 내장된 기본 자료형은 다음과 같습니다:

- 리터럴
  - **null**: `std.null`을 사용하여 생성할 수 있습니다.
  - **boolean**: `std.true`와 `std.false`로 표현됩니다.
  - **number**: 64비트 부동 소수점 숫자입니다.
  - **string**: UTF-8 문자열입니다.
  - **symbol**: 정수에 매핑되는 특별한 종류의 문자열입니다.
- 컨테이너
  - **array**: 값의 컬렉션입니다.
  - **object**: 키-값 쌍의 컬렉션입니다.
- 함수
  - **closure**: 주변 범위에서 바인딩을 캡처하는 함수입니다.
- 특수값
  - **makrer**: 스택 조작에 사용되는 고유하고 식별 가능한 값입니다.

---

## 4. 코루틴과 비동기 작업

WIP

## A. 표준 라이브러리

WIP

## B. 시스템 의존적인 기능

WIP

## X. Example Programs

WIP

#!/usr/bin/env intj

// INTJ Specification in code!


// -1. Most important things: Comments.

// This is a line comment
/// This is a document comment.
/* Also, block comments */

// As other script languages, shebang is also considered as a comment, everywhere
#! <- it's not problem.

// -1-1. Notation of stack.
// In this document, we will denote the stack as [1, 2, 3].
// The top of stack is the leftmost element.
// Also, I'll skip some elements below by ellipsis, like [1, 2, ..., 5, ...].


// 0. What is INTJ?
// Intelligent JSON (INTJ) is a very simple language which can accept JSON.

// * INTJ is a stack-oriented language.
// In other words, the program has a stack to store any variables and etc.
// Every keywords / functions manipulates the stack (basically, most are push).

// * INTJ is dynamically typed.
// Each stack cell can store any type of data.

// * INTJ accepts JSON
// Every JSON code is valid INTJ code, which just push a JSON object to the stack.
// Since INTJ is a superset of JSON,
// the meaning of each symbol in JSON slightly differnt.

// * Functions are first-class.
// Nothing is special about functions.
// As other values, function can be pushed to the stack.
// Also, functions are just a list of commands.

// * All bindings are immutable.
// INTJ does not allow to change the value of a variable.
// This will make the program more predictable and easier to debug.

// Comments are ignored by the parser.


// 1. Language Basics

// INTJ is a stack-oriented language.
// Every keywords manipulates the stack (basically, most are push).
// They are evaluated top-down, right to left.

// 1-1. Separator
// In INTJ, newline and comma (',') are considered as 'separator'.
// As mentioned above, INTJ is evaluated top-down, right to left.
// The separator is used to distinguish lines.

// For example let's consider the following code:
1 2 3 4 5 6
// This code will be evaluated from 6 to 1. (The stack will be: [6, 5, 4, 3, 2, 1])
// However, you may want to execute '4 5 6' first, and then '1 2 3'.
// Then, you can use a separator to distinguish them:
4 5 6, 1 2 3
// or
4 5 6
1 2 3
// And the result is sample.
// You'll see the readibility is improved by using separators in real codes
// For example, instead of:
print square + 3 parse_int readline
// The below code is more reasonable:
readline  // First read a line
parse_int // Then parse it to integer
+ 3       // Add 3
square    // Take a square
print     // print!

// 1-2. Literals
// INTJ's literal are based on JS's literal, except undefined.
// Each atom will push the literal to the stack.

true false null 42 "Hello, world!"

// The above will push literals.
// Note that because of evaluation order, the top of stack is true.

// Also, string is more flexible than JSON. For example,
'hello,\nworld!' // single quote
"asd \a \022 " // Some c escape sequences are allowed.

// 1-3. Symbols
// Symbols are some special kind of string, bound to an integer.
// They are used to key of object, for fast equality comparison.
// The easiest way to define a symbol is to use `:` after string.

"hello": // => Symbol 'hello'
'world': // => Symbol 'world'
"good" : // => Whitespaces between quotation mark and colon are allowed.

// Also, after identifier, you can put `:` to convert it to symbol.
// (A word without reserved characters is considered as identifier)
// For example:
my-good-value: // => Symbol 'my-good-value'
wow!ItWorks : // => Symbol 'wow!ItWorks'

// To convert the symbol to integer, or inverse, use some standard functions.

// 1-4. Array, Object

// To construct array and object, use `[]` and `{}`.
// You can use they as same as JSON. For example:

[1, 3,
5] // => [1, 3, 5]

{"a": 1, "b": 2} // => {a: 1, b: 2}

// The interesting thing is nothing special except the brackets.
// The comma is just a separator, and colon makes the previous string to symbol.
// In other words, you can omit / repeat commas, or omit quotes as follows:

[1
 3
 {
	  header: "test",,, body : "test"
 }]
// => [1, 3, {header: "test", body: "test"}]
// This shows INTJ also accepts JSON5, or more flexible than JSON5,
// except newline cannot be come between quotes and colon in object keys.

// How it works? I'll explain it later.

// 1-5. Identifier and functions
// INTJ has few reserved characters,
// - Whitespaces, ',', ':', brackets '()[]{}', hash '#', quotes '"', ''', '`'.
// Except these, any characters are allowed in identifier. (If it's not a literal)

hello world good! + ** test<-20 // Each of them are valid identifier.

// If you want to include some special characters, use backticks.
// Note that backticks does not allow newline, backticks, and no escape.
`hello, world!` // => Identifier 'hello, world!'

// You can bind a function to an identifier by using `=`.

a = 42
b = "Hello, world!"
c=[1, 2, 3] // Not recommended but allowed.
+ = add // The id looks like operator also allowed.
`abc=` = abc // Backticks also allowed.

// Note that binding is not special. '<ID> =' token just pop a value, and bind.
// For example, the above is also valid:
a= b= c= 1 2 3
// It means, push 3, 2, 1, then pop and bind to c, pop and bind to b, pop and bind to a.
// Thus, equivalent to
a = 1
b = 2
c = 3

// If you bind a literal to an identifer, the id is a kind of function,
// which just push the literal to the stack.
// For example,
a = 42
print a // Push a (=42) then print. Thus 42 will be printed.

// 1-6. Functions
// Functions are just a list of words.
// By enclosing them with `()`, you can define.
// For example:

pop_and_double = (* 2 pop)
swap = ( // Multi-line also allowed
	a= b= // First line executed first, this'll pop to b, pop to a
	a b // And push b, push a
)
construct_json = ({
	"hello": "world"
})

// (...) will push the function to the stack.
// Once bound, you just say the word to invoke.
construct_json // It'll invoke ({"hello": "world"}), push the object to the stack.
pop_and_double 3 2 // Push 2, 3 and invoke (* 2 pop), thus, 4.

// 1-7. Array and Object, how it works?

// OK. Let's see how array and object works.
// In INTJ, array and object is a syntatic sugar of 'object', and 'array' with function.
// For example, you can create an array as follows.
array (1, 2, 3) // => Equivalent to [1, 2, 3]
// If you decompose the above code step by step,
// - First push a function.
//   - The function just push literals, in order of 3, 2, 1.
// - Then, invoke a function 'array'.

// The special thing is 'array' function.
// It takes a single function, which pushes values for array.
// array works as follows:
array = (
	value_fn = // Pop the given value-push function
	push_array_start_mark // Push the start mark of array
	value_fn // Push values by invoking the function
	reduce_stack_to_array_until_start_mark // Reduce the stack to array
)
// Therefore, if you does not corrupt the start mark,
// you can do anything during constructing array.
// For example, you may mix some operations in the array.
[
	+ 32 10 // => equivalent to push 42
	trim "  hello world " // => equivalent to push "hello world"
]

// Object is also similar.
// Instead the array only takes value, object takes key-value pair, with symbol.
// For example,
{
	"number": 42,
	value: 5
}
// works as follows:
// - As array, keep value function (number: 42, value: 5), and set a start mark
// - Evaluate the function
//   - Because of execution order, the stack will be [number:, 42, value, 5]
// - Reduce the stack to object.

// If you are more familiar with stack manipulation,
// you can construct array and object more complicated way (but useless.)
// For example, swap, which pop 2 values and push them in reverse order,

[ 1, 2, swap ] // => [2, 1]
{
	[ key1:, key2:, my-val: ]
	[ 42, true, null ]
	push_zip // This takes to arrays and push them interleaved.
} // => {key1: 42, key2: true, my-val: null}


